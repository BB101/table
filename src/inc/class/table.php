<?php
//this class represents a table in the database
//table declarations will be autogenerated
class table {
  public $table; //table name
  public $keys = array(); //array of table (primary) keys
  public $unique = array(); //array of unique keys, including primary
  public $fields = array(); //list of fields
  
  /*
  class initialiser
  $params = array(
    "table" => database table,
    "keys" => array(primary keys),
    "fields" => array(field => array(name, type, params))
    optionally...
    "view_class" => class used for views
    "row_class" => class used for a row
  );
  */
  public $view_class = "table_view"; //overrideables
  public $row_class = "table_row";
  public function __construct($params) {
    $this->table = $params['table'];
    $this->keys = $params['keys'];
    $this->unique = $params['unique'];
    $this->fields = $params['fields'];
    
    if (isset($params['view_class']) && $params['view_class']) $this->view_class = $params['view_class'];
    if (isset($params['row_class']) && $params['row_class']) $this->row_class = $params['row_class'];
  }

  function __toString() {
    return "new table(".json_encode(array("table" => $this->table)).")";
  }


  /*
  add relationships between different tables
  $params = array(
    "type" => "one", "many", "parent" or "child"
      one = have a foreign key in this table
      many = have our primary key in another table    
      parent = the inherited parent for this table
      child = opposite of above, child of this table

    "name" => binding name, used for $item_or_view = $this->{$name}
    "table" => table instance object
    "binding" => array(key in this table => key in other table)
  )
  */
  public $link = array(); //array of one/many relationships
  public $parent = false; public $children = array(); //parent/child relationships
  public function add_link($params) {
    //check the parameters
    if ($params['type'] == "one" || $params['type'] == "many") {
      $this->link[$params['name']] = $params;
    } else if ($params['type'] == "parent") {
      $this->parent = $params;
    } else if ($params['type'] == "child") {
      $this->children[$params['name']] = $params;
    }
    return $this;
  }

  /*
  $search = "field = 'value'", "table.field.value <> 'value'", "link[.link..].field LIKE 'value'", etc
  nested logic brackets,
  operators AND, OR
  conditions LIKE, =, !=, <, <=, etc
  $order = "field ASC, field2 DESC", etc
  if you provide it with all unique keys for this table it will return a table_row
  otherwise it'll return a table_view based on your search
  */
  public $get_cache = array();
  public function get($search = "1=1", $order = null) {
    $class = $this->view_class;
    return new $class($this, $search, $order);
  }
  
  public function delete($search) {
    da::delete($this, $search);
  }
  
  public function save($fields) {
    $ref =& $this;
    $data = array();
    do {
      $ks = array(); $vs = array();
      foreach ($fields as $k => $v) {
        $k = explode(".", $k, 2);
        if (count($k) == 1) {
          if (isset($ref->fields[$k[0]])) {
            $ks[] = $k[0];
            $vs[] = $v;
          }          
        } else if ($k[0] == $ref->table && isset($ref->fields[$k[1]])) {
          $ks[] = $k[1];
          $vs[] = $v;
        }
      }

      $data[$ref->table] = array($ks,$vs,$ref);
      $ref =& $ref->parent['table'];
    } while ($ref);
    $data = array_reverse($data);
    return da::save($data);
  }
}
?>